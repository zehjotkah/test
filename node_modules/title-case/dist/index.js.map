{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["const TOKENS = /(\\S+)|(.)/g;\nconst IS_SPECIAL_CASE = /[\\.#][\\p{L}\\p{N}]/u; // #tag, example.com, etc.\nconst IS_MANUAL_CASE = /\\p{Ll}(?=[\\p{Lu}])/u; // iPhone, iOS, etc.\nconst ALPHANUMERIC_PATTERN = /[\\p{L}\\p{N}]+/gu;\nconst IS_ACRONYM = /^([^\\p{L}])*(?:\\p{L}\\.){2,}([^\\p{L}])*$/u;\n\nexport const WORD_SEPARATORS = new Set([\"—\", \"–\", \"-\", \"―\", \"/\"]);\n\nexport const SENTENCE_TERMINATORS = new Set([\".\", \"!\", \"?\"]);\n\nexport const TITLE_TERMINATORS = new Set([\n  ...SENTENCE_TERMINATORS,\n  \":\",\n  '\"',\n  \"'\",\n  \"”\",\n]);\n\nexport const SMALL_WORDS = new Set([\n  \"a\",\n  \"an\",\n  \"and\",\n  \"as\",\n  \"at\",\n  \"because\",\n  \"but\",\n  \"by\",\n  \"en\",\n  \"for\",\n  \"if\",\n  \"in\",\n  \"neither\",\n  \"nor\",\n  \"of\",\n  \"on\",\n  \"only\",\n  \"or\",\n  \"over\",\n  \"per\",\n  \"so\",\n  \"some\",\n  \"than\",\n  \"that\",\n  \"the\",\n  \"to\",\n  \"up\",\n  \"upon\",\n  \"v\",\n  \"versus\",\n  \"via\",\n  \"vs\",\n  \"when\",\n  \"with\",\n  \"without\",\n  \"yet\",\n]);\n\nexport interface Options {\n  locale?: string | string[];\n  sentenceCase?: boolean;\n  sentenceTerminators?: Set<string>;\n  smallWords?: Set<string>;\n  titleTerminators?: Set<string>;\n  wordSeparators?: Set<string>;\n}\n\nexport function titleCase(\n  input: string,\n  options: Options | string[] | string = {},\n) {\n  const {\n    locale = undefined,\n    sentenceCase = false,\n    sentenceTerminators = SENTENCE_TERMINATORS,\n    titleTerminators = TITLE_TERMINATORS,\n    smallWords = SMALL_WORDS,\n    wordSeparators = WORD_SEPARATORS,\n  } = typeof options === \"string\" || Array.isArray(options)\n    ? { locale: options }\n    : options;\n\n  const terminators = sentenceCase ? sentenceTerminators : titleTerminators;\n  let result = \"\";\n  let isNewSentence = true;\n\n  // tslint:disable-next-line\n  for (const m of input.matchAll(TOKENS)) {\n    const { 1: token, 2: whiteSpace, index = 0 } = m;\n\n    if (whiteSpace) {\n      result += whiteSpace;\n      continue;\n    }\n\n    // Ignore URLs, email addresses, acronyms, etc.\n    if (IS_SPECIAL_CASE.test(token)) {\n      const acronym = token.match(IS_ACRONYM);\n\n      // The period at the end of an acronym is not a new sentence,\n      // but we should uppercase first for i.e., e.g., etc.\n      if (acronym) {\n        const [_, prefix = \"\", suffix = \"\"] = acronym;\n        result +=\n          sentenceCase && !isNewSentence\n            ? token\n            : upperAt(token, prefix.length, locale);\n        isNewSentence = terminators.has(suffix.charAt(0));\n        continue;\n      }\n\n      result += token;\n      isNewSentence = terminators.has(token.charAt(token.length - 1));\n    } else {\n      const matches = Array.from(token.matchAll(ALPHANUMERIC_PATTERN));\n      let value = token;\n      let isSentenceEnd = false;\n\n      for (let i = 0; i < matches.length; i++) {\n        const { 0: word, index: wordIndex = 0 } = matches[i];\n        const nextChar = token.charAt(wordIndex + word.length);\n\n        isSentenceEnd = terminators.has(nextChar);\n\n        // Always the capitalize first word and reset \"new sentence\".\n        if (isNewSentence) {\n          isNewSentence = false;\n        }\n        // Skip capitalizing all words if sentence case is enabled.\n        else if (sentenceCase || IS_MANUAL_CASE.test(word)) {\n          continue;\n        }\n        // Handle simple words.\n        else if (matches.length === 1) {\n          // Avoid capitalizing small words, except at the end of a sentence.\n          if (smallWords.has(word)) {\n            const isFinalToken = index + token.length === input.length;\n\n            if (!isFinalToken && !isSentenceEnd) {\n              continue;\n            }\n          }\n        }\n        // Multi-word tokens need to be parsed differently.\n        else if (i > 0) {\n          // Avoid capitalizing words without a valid word separator,\n          // e.g. \"apple's\" or \"test(ing)\".\n          if (!wordSeparators.has(token.charAt(wordIndex - 1))) {\n            continue;\n          }\n\n          // Ignore small words in the middle of hyphenated words.\n          if (smallWords.has(word) && wordSeparators.has(nextChar)) {\n            continue;\n          }\n        }\n\n        value = upperAt(value, wordIndex, locale);\n      }\n\n      result += value;\n      isNewSentence =\n        isSentenceEnd || terminators.has(token.charAt(token.length - 1));\n    }\n  }\n\n  return result;\n}\n\nfunction upperAt(\n  input: string,\n  index: number,\n  locale: string | string[] | undefined,\n) {\n  return (\n    input.slice(0, index) +\n    input.charAt(index).toLocaleUpperCase(locale) +\n    input.slice(index + 1)\n  );\n}\n"]}