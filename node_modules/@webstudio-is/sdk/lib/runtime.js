// src/resource-loader.ts
var LOCAL_RESOURCE_PREFIX = "$resources";
var isLocalResource = (pathname, resourceName) => {
  const segments = pathname.split("/").filter(Boolean);
  if (resourceName === void 0) {
    return segments[0] === LOCAL_RESOURCE_PREFIX;
  }
  return segments.join("/") === `${LOCAL_RESOURCE_PREFIX}/${resourceName}`;
};
var sitemapResourceUrl = `/${LOCAL_RESOURCE_PREFIX}/sitemap.xml`;
var loadResource = async (customFetch, resourceRequest) => {
  const { url, method, headers, body } = resourceRequest;
  const requestHeaders = new Headers(
    headers.map(({ name, value }) => [name, value])
  );
  const requestInit = {
    method,
    headers: requestHeaders
  };
  if (method !== "get" && body !== void 0) {
    if (typeof body === "string") {
      requestInit.body = body;
    }
    if (typeof body === "object") {
      requestInit.body = JSON.stringify(body);
    }
  }
  try {
    const response = await customFetch(url.trim(), requestInit);
    let data = await response.text();
    try {
      data = JSON.parse(data);
    } catch {
    }
    if (!response.ok) {
      console.error(
        `Failed to load resource: ${url} - ${response.status}: ${JSON.stringify(data).slice(0, 300)}`
      );
    }
    return {
      ok: response.ok,
      data,
      status: response.status,
      statusText: response.statusText
    };
  } catch (error) {
    console.error(error);
    const message = error.message;
    return {
      ok: false,
      data: void 0,
      status: 500,
      statusText: message
    };
  }
};
var loadResources = async (customFetch, requests) => {
  return Object.fromEntries(
    await Promise.all(
      Array.from(
        requests,
        async ([name, request]) => [name, await loadResource(customFetch, request)]
      )
    )
  );
};

// src/to-string.ts
var createJsonStringifyProxy = (target) => {
  return new Proxy(target, {
    get(target2, prop, receiver) {
      if (prop === "toString") {
        return function() {
          return JSON.stringify(target2);
        };
      }
      const value = Reflect.get(target2, prop, receiver);
      if (typeof value === "object" && value !== null) {
        return createJsonStringifyProxy(value);
      }
      return value;
    }
  });
};
var isPlainObject = (value) => {
  return Object.prototype.toString.call(value) === "[object Object]" && (Object.getPrototypeOf(value) === null || Object.getPrototypeOf(value) === Object.prototype);
};

// src/form-fields.ts
var formIdFieldName = `ws--form-id`;
var formBotFieldName = `ws--form-bot`;
export {
  createJsonStringifyProxy,
  formBotFieldName,
  formIdFieldName,
  isLocalResource,
  isPlainObject,
  loadResource,
  loadResources,
  sitemapResourceUrl
};
