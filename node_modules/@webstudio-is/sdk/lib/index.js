// src/schema/assets.ts
import { z } from "zod";
import { FontFormat, FontMeta } from "@webstudio-is/fonts";
var AssetId = z.string();
var baseAsset = {
  id: AssetId,
  projectId: z.string(),
  size: z.number(),
  name: z.string(),
  description: z.union([z.string(), z.null()]),
  createdAt: z.string()
};
var FontAsset = z.object({
  ...baseAsset,
  format: FontFormat,
  meta: FontMeta,
  type: z.literal("font")
});
var ImageMeta = z.object({
  width: z.number(),
  height: z.number()
});
var ImageAsset = z.object({
  ...baseAsset,
  format: z.string(),
  meta: ImageMeta,
  type: z.literal("image")
});
var Asset = z.union([FontAsset, ImageAsset]);
var Assets = z.map(AssetId, Asset);

// src/schema/pages.ts
import { z as z2 } from "zod";
var MIN_TITLE_LENGTH = 2;
var PageId = z2.string();
var FolderId = z2.string();
var FolderName = z2.string().refine((value) => value.trim() !== "", "Can't be empty");
var Slug = z2.string().refine(
  (path) => /^[-a-z0-9]*$/.test(path),
  "Only a-z, 0-9 and - are allowed"
);
var Folder = z2.object({
  id: FolderId,
  name: FolderName,
  slug: Slug,
  children: z2.array(z2.union([FolderId, PageId]))
});
var PageName = z2.string().refine((value) => value.trim() !== "", "Can't be empty");
var PageTitle = z2.string().refine(
  (val) => val.length >= MIN_TITLE_LENGTH,
  `Minimum ${MIN_TITLE_LENGTH} characters required`
);
var documentTypes = ["html", "xml"];
var commonPageFields = {
  id: PageId,
  name: PageName,
  title: PageTitle,
  history: z2.optional(z2.array(z2.string())),
  rootInstanceId: z2.string(),
  systemDataSourceId: z2.string(),
  meta: z2.object({
    description: z2.string().optional(),
    title: z2.string().optional(),
    excludePageFromSearch: z2.string().optional(),
    language: z2.string().optional(),
    socialImageAssetId: z2.string().optional(),
    socialImageUrl: z2.string().optional(),
    status: z2.string().optional(),
    redirect: z2.string().optional(),
    documentType: z2.optional(z2.enum(documentTypes)),
    custom: z2.array(
      z2.object({
        property: z2.string(),
        content: z2.string()
      })
    ).optional()
  }),
  marketplace: z2.optional(
    z2.object({
      include: z2.optional(z2.boolean()),
      category: z2.optional(z2.string()),
      thumbnailAssetId: z2.optional(z2.string())
    })
  )
};
var HomePagePath = z2.string().refine((path) => path === "", "Home page path must be empty");
var HomePage = z2.object({
  ...commonPageFields,
  path: HomePagePath
});
var PagePath = z2.string().refine((path) => path !== "", "Can't be empty").refine((path) => path !== "/", "Can't be just a /").refine((path) => path === "" || path.startsWith("/"), "Must start with a /").refine((path) => path.endsWith("/") === false, "Can't end with a /").refine((path) => path.includes("//") === false, "Can't contain repeating /").refine(
  (path) => /^[-_a-z0-9*:?\\/.]*$/.test(path),
  "Only a-z, 0-9, -, _, /, :, ?, . and * are allowed"
).refine(
  // We use /s for our system stuff like /s/css or /s/uploads
  (path) => path !== "/s" && path.startsWith("/s/") === false,
  "/s prefix is reserved for the system"
).refine(
  // Remix serves build artefacts like JS bundles from /build
  // And we cannot customize it due to bug in Remix: https://github.com/remix-run/remix/issues/2933
  (path) => path !== "/build" && path.startsWith("/build/") === false,
  "/build prefix is reserved for the system"
);
var Page = z2.object({
  ...commonPageFields,
  path: PagePath
});
var ProjectMeta = z2.object({
  // All fields are optional to ensure consistency and allow for the addition of new fields without requiring migration
  siteName: z2.string().optional(),
  contactEmail: z2.string().optional(),
  faviconAssetId: z2.string().optional(),
  code: z2.string().optional()
});
var ProjectNewRedirectPath = PagePath.or(
  z2.string().refine((data) => {
    if (data === "/") {
      return true;
    }
    try {
      new URL(data);
      return true;
    } catch {
      return false;
    }
  }, "Must be a valid URL")
);
var PageRedirect = z2.object({
  old: PagePath,
  new: ProjectNewRedirectPath,
  status: z2.enum(["301", "302"]).optional()
});
var CompilerSettings = z2.object({
  // All fields are optional to ensure consistency and allow for the addition of new fields without requiring migration
  atomicStyles: z2.boolean().optional()
});
var Pages = z2.object({
  meta: ProjectMeta.optional(),
  compiler: CompilerSettings.optional(),
  redirects: z2.array(PageRedirect).optional(),
  homePage: HomePage,
  pages: z2.array(Page),
  folders: z2.array(Folder).refine((folders) => folders.length > 0, "Folders can't be empty")
});

// src/schema/instances.ts
import { z as z3 } from "zod";
var TextChild = z3.object({
  type: z3.literal("text"),
  value: z3.string(),
  placeholder: z3.boolean().optional()
});
var InstanceId = z3.string();
var IdChild = z3.object({
  type: z3.literal("id"),
  value: InstanceId
});
var ExpressionChild = z3.object({
  type: z3.literal("expression"),
  value: z3.string()
});
var InstanceChild = z3.union([IdChild, TextChild, ExpressionChild]);
var Instance = z3.object({
  type: z3.literal("instance"),
  id: InstanceId,
  component: z3.string(),
  label: z3.string().optional(),
  children: z3.array(InstanceChild)
});
var Instances = z3.map(InstanceId, Instance);
var MatcherRelation = z3.union([
  z3.literal("ancestor"),
  z3.literal("parent"),
  z3.literal("self"),
  z3.literal("child"),
  z3.literal("descendant")
]);
var MatcherOperation = z3.object({
  $eq: z3.string().optional(),
  $neq: z3.string().optional(),
  $in: z3.array(z3.string()).optional(),
  $nin: z3.array(z3.string()).optional()
});
var Matcher = z3.object({
  relation: MatcherRelation,
  component: MatcherOperation.optional(),
  tag: MatcherOperation.optional()
});
var Matchers = z3.union([Matcher, z3.array(Matcher)]);

// src/schema/data-sources.ts
import { z as z4 } from "zod";
var DataSourceId = z4.string();
var DataSourceVariableValue = z4.union([
  z4.object({
    type: z4.literal("number"),
    // initial value of variable store
    value: z4.number()
  }),
  z4.object({
    type: z4.literal("string"),
    value: z4.string()
  }),
  z4.object({
    type: z4.literal("boolean"),
    value: z4.boolean()
  }),
  z4.object({
    type: z4.literal("string[]"),
    value: z4.array(z4.string())
  }),
  z4.object({
    type: z4.literal("json"),
    value: z4.unknown()
  })
]);
var DataSource = z4.union([
  z4.object({
    type: z4.literal("variable"),
    id: DataSourceId,
    scopeInstanceId: z4.optional(z4.string()),
    name: z4.string(),
    value: DataSourceVariableValue
  }),
  z4.object({
    type: z4.literal("parameter"),
    id: DataSourceId,
    scopeInstanceId: z4.optional(z4.string()),
    name: z4.string()
  }),
  z4.object({
    type: z4.literal("resource"),
    id: DataSourceId,
    scopeInstanceId: z4.optional(z4.string()),
    name: z4.string(),
    resourceId: z4.string()
  })
]);
var DataSources = z4.map(DataSourceId, DataSource);

// src/schema/resources.ts
import { z as z5 } from "zod";
var ResourceId = z5.string();
var Method = z5.union([
  z5.literal("get"),
  z5.literal("post"),
  z5.literal("put"),
  z5.literal("delete")
]);
var Header = z5.object({
  name: z5.string(),
  // expression
  value: z5.string()
});
var Resource = z5.object({
  id: ResourceId,
  name: z5.string(),
  control: z5.optional(z5.union([z5.literal("system"), z5.literal("graphql")])),
  method: Method,
  // expression
  url: z5.string(),
  headers: z5.array(Header),
  // expression
  body: z5.optional(z5.string())
});
var ResourceRequest = z5.object({
  id: ResourceId,
  name: z5.string(),
  method: Method,
  url: z5.string(),
  headers: z5.array(Header),
  body: z5.optional(z5.unknown())
});
var Resources = z5.map(ResourceId, Resource);

// src/schema/props.ts
import { z as z6 } from "zod";
var PropId = z6.string();
var baseProp = {
  id: PropId,
  instanceId: z6.string(),
  name: z6.string(),
  required: z6.optional(z6.boolean())
};
var Prop = z6.union([
  z6.object({
    ...baseProp,
    type: z6.literal("number"),
    value: z6.number()
  }),
  z6.object({
    ...baseProp,
    type: z6.literal("string"),
    value: z6.string()
  }),
  z6.object({
    ...baseProp,
    type: z6.literal("boolean"),
    value: z6.boolean()
  }),
  z6.object({
    ...baseProp,
    type: z6.literal("json"),
    value: z6.unknown()
  }),
  z6.object({
    ...baseProp,
    type: z6.literal("asset"),
    value: z6.string()
    // asset id
  }),
  z6.object({
    ...baseProp,
    type: z6.literal("page"),
    value: z6.union([
      z6.string(),
      // page id
      z6.object({
        pageId: z6.string(),
        instanceId: z6.string()
      })
    ])
  }),
  z6.object({
    ...baseProp,
    type: z6.literal("string[]"),
    value: z6.array(z6.string())
  }),
  z6.object({
    ...baseProp,
    type: z6.literal("parameter"),
    // data source id
    value: z6.string()
  }),
  z6.object({
    ...baseProp,
    type: z6.literal("resource"),
    // resource id
    value: z6.string()
  }),
  z6.object({
    ...baseProp,
    type: z6.literal("expression"),
    // expression code
    value: z6.string()
  }),
  z6.object({
    ...baseProp,
    type: z6.literal("action"),
    value: z6.array(
      z6.object({
        type: z6.literal("execute"),
        args: z6.array(z6.string()),
        code: z6.string()
      })
    )
  })
]);
var Props = z6.map(PropId, Prop);

// src/schema/breakpoints.ts
import { z as z7 } from "zod";
var BreakpointId = z7.string();
var Breakpoint = z7.object({
  id: BreakpointId,
  label: z7.string(),
  minWidth: z7.number().optional(),
  maxWidth: z7.number().optional()
}).refine(({ minWidth, maxWidth }) => {
  return (
    // Either min or max width have to be defined
    minWidth !== void 0 && maxWidth === void 0 || minWidth === void 0 && maxWidth !== void 0 || // This is a base breakpoint
    minWidth === void 0 && maxWidth === void 0
  );
}, "Either minWidth or maxWidth should be defined");
var Breakpoints = z7.map(BreakpointId, Breakpoint);
var initialBreakpoints = [
  { id: "placeholder", label: "Base" },
  { id: "placeholder", label: "Tablet", maxWidth: 991 },
  { id: "placeholder", label: "Mobile landscape", maxWidth: 767 },
  { id: "placeholder", label: "Mobile portrait", maxWidth: 479 }
];

// src/schema/style-sources.ts
import { z as z8 } from "zod";
var StyleSourceId = z8.string();
var StyleSourceToken = z8.object({
  type: z8.literal("token"),
  id: StyleSourceId,
  name: z8.string()
});
var StyleSourceLocal = z8.object({
  type: z8.literal("local"),
  id: StyleSourceId
});
var StyleSource = z8.union([StyleSourceToken, StyleSourceLocal]);
var StyleSources = z8.map(StyleSourceId, StyleSource);

// src/schema/style-source-selections.ts
import { z as z9 } from "zod";
var InstanceId2 = z9.string();
var StyleSourceId2 = z9.string();
var StyleSourceSelection = z9.object({
  instanceId: InstanceId2,
  values: z9.array(StyleSourceId2)
});
var StyleSourceSelections = z9.map(InstanceId2, StyleSourceSelection);

// src/schema/styles.ts
import { z as z10 } from "zod";
import { StyleValue } from "@webstudio-is/css-engine";
var StyleDeclRaw = z10.object({
  styleSourceId: z10.string(),
  breakpointId: z10.string(),
  state: z10.optional(z10.string()),
  // @todo can't figure out how to make property to be enum
  property: z10.string(),
  value: StyleValue,
  listed: z10.boolean().optional()
});
var StyleDecl = StyleDeclRaw;
var getStyleDeclKey = (styleDecl) => {
  return `${styleDecl.styleSourceId}:${styleDecl.breakpointId}:${styleDecl.property}:${styleDecl.state ?? ""}`;
};
var Styles = z10.map(z10.string(), StyleDecl);

// src/schema/deployment.ts
import { z as z11 } from "zod";
var Templates = z11.enum([
  "vanilla",
  "vercel",
  "netlify-functions",
  "netlify-edge-functions",
  "ssg",
  "ssg-netlify",
  "ssg-vercel"
]);
var Deployment = z11.union([
  z11.object({
    destination: z11.literal("static"),
    name: z11.string(),
    assetsDomain: z11.string(),
    // Must be validated very strictly
    templates: z11.array(Templates)
  }),
  z11.object({
    destination: z11.literal("saas").optional(),
    domains: z11.array(z11.string()),
    assetsDomain: z11.string().optional(),
    /**
     * @deprecated This field is deprecated, use `domains` instead.
     */
    projectDomain: z11.string().optional(),
    excludeWstdDomainFromSearch: z11.boolean().optional()
  })
]);

// src/schema/webstudio.ts
import { z as z12 } from "zod";
var WebstudioFragment = z12.object({
  children: z12.array(InstanceChild),
  instances: z12.array(Instance),
  assets: z12.array(Asset),
  dataSources: z12.array(DataSource),
  resources: z12.array(Resource),
  props: z12.array(Prop),
  breakpoints: z12.array(Breakpoint),
  styleSourceSelections: z12.array(StyleSourceSelection),
  styleSources: z12.array(StyleSource),
  styles: z12.array(StyleDecl)
});

// src/instances-utils.ts
var ROOT_INSTANCE_ID = ":root";
var traverseInstances = (instances, instanceId, callback) => {
  const instance = instances.get(instanceId);
  if (instance === void 0) {
    return;
  }
  const skipTraversingChildren = callback(instance);
  if (skipTraversingChildren === false) {
    return;
  }
  for (const child of instance.children) {
    if (child.type === "id") {
      traverseInstances(instances, child.value, callback);
    }
  }
};
var findTreeInstanceIds = (instances, rootInstanceId) => {
  const ids = /* @__PURE__ */ new Set([rootInstanceId]);
  traverseInstances(instances, rootInstanceId, (instance) => {
    ids.add(instance.id);
  });
  return ids;
};
var findTreeInstanceIdsExcludingSlotDescendants = (instances, rootInstanceId) => {
  const ids = /* @__PURE__ */ new Set([rootInstanceId]);
  traverseInstances(instances, rootInstanceId, (instance) => {
    ids.add(instance.id);
    if (instance.component === "Slot") {
      return false;
    }
  });
  return ids;
};
var parseComponentName = (componentName) => {
  const parts = componentName.split(":");
  let namespace;
  let name;
  if (parts.length === 1) {
    [name] = parts;
  } else {
    [namespace, name] = parts;
  }
  return [namespace, name];
};

// src/expression.ts
import { parseExpressionAt } from "acorn";
import { simple } from "acorn-walk";
var lintExpression = ({
  expression,
  availableVariables = /* @__PURE__ */ new Set(),
  allowAssignment = false
}) => {
  const diagnostics = [];
  const addError = (message) => {
    return (node) => {
      diagnostics.push({
        // tune error position after wrapping expression with parentheses
        from: node.start - 1,
        to: node.end - 1,
        severity: "error",
        message
      });
    };
  };
  if (expression.trim().length === 0) {
    diagnostics.push({
      from: 0,
      to: 0,
      severity: "error",
      message: "Expression cannot be empty"
    });
    return diagnostics;
  }
  try {
    const root = parseExpressionAt(`(${expression})`, 0, {
      ecmaVersion: "latest",
      // support parsing import to forbid explicitly
      sourceType: "module"
    });
    simple(root, {
      Identifier(node) {
        if (availableVariables.has(node.name) === false) {
          addError(`"${node.name}" is not defined in the scope`)(node);
        }
      },
      Literal() {
      },
      ArrayExpression() {
      },
      ObjectExpression() {
      },
      UnaryExpression() {
      },
      BinaryExpression() {
      },
      LogicalExpression() {
      },
      MemberExpression() {
      },
      ConditionalExpression() {
      },
      TemplateLiteral() {
      },
      ChainExpression() {
      },
      ParenthesizedExpression() {
      },
      AssignmentExpression(node) {
        if (allowAssignment === false) {
          addError("Assignment is supported only inside actions")(node);
          return;
        }
        simple(node.left, {
          Identifier(node2) {
            if (availableVariables.has(node2.name) === false) {
              addError(`"${node2.name}" is not defined in the scope`)(node2);
            }
          }
        });
      },
      // parser forbids to yield inside module
      YieldExpression() {
      },
      ThisExpression: addError(`"this" keyword is not supported`),
      FunctionExpression: addError("Functions are not supported"),
      UpdateExpression: addError("Increment and decrement are not supported"),
      CallExpression: addError("Functions are not supported"),
      NewExpression: addError("Classes are not supported"),
      SequenceExpression: addError(`Only single expression is supported`),
      ArrowFunctionExpression: addError("Functions are not supported"),
      TaggedTemplateExpression: addError("Tagged template is not supported"),
      ClassExpression: addError("Classes are not supported"),
      MetaProperty: addError("Imports are not supported"),
      AwaitExpression: addError(`"await" keyword is not supported`),
      ImportExpression: addError("Imports are not supported")
    });
  } catch (error) {
    const castedError = error;
    diagnostics.push({
      // tune error position after wrapping expression with parentheses
      from: castedError.pos - 1,
      to: castedError.pos - 1,
      severity: "error",
      // trim auto generated error location
      // to not conflict with tuned position
      message: castedError.message.replaceAll(/\s+\(\d+:\d+\)$/g, "")
    });
  }
  return diagnostics;
};
var isLiteralNode = (node) => {
  if (node.type === "Literal") {
    return true;
  }
  if (node.type === "ArrayExpression") {
    return node.elements.every((node2) => {
      if (node2 === null || node2.type === "SpreadElement") {
        return false;
      }
      return isLiteralNode(node2);
    });
  }
  if (node.type === "ObjectExpression") {
    return node.properties.every((property) => {
      if (property.type === "SpreadElement") {
        return false;
      }
      const key = property.key;
      const isIdentifierKey = key.type === "Identifier" && property.computed === false;
      const isLiteralKey = key.type === "Literal";
      return (isLiteralKey || isIdentifierKey) && isLiteralNode(property.value);
    });
  }
  return false;
};
var isLiteralExpression = (expression) => {
  try {
    const node = parseExpressionAt(expression, 0, { ecmaVersion: "latest" });
    return isLiteralNode(node);
  } catch {
    return false;
  }
};
var getExpressionIdentifiers = (expression) => {
  const identifiers2 = /* @__PURE__ */ new Set();
  try {
    const root = parseExpressionAt(expression, 0, { ecmaVersion: "latest" });
    simple(root, {
      Identifier: (node) => identifiers2.add(node.name),
      AssignmentExpression(node) {
        simple(node.left, {
          Identifier: (node2) => identifiers2.add(node2.name)
        });
      }
    });
  } catch {
  }
  return identifiers2;
};
var transpileExpression = ({
  expression,
  executable = false,
  replaceVariable
}) => {
  let root;
  try {
    root = parseExpressionAt(expression, 0, { ecmaVersion: "latest" });
  } catch (error) {
    const message = error.message;
    throw Error(`${message} in ${JSON.stringify(expression)}`);
  }
  const replacements = [];
  const replaceIdentifier = (node, assignee) => {
    const newName = replaceVariable?.(node.name, assignee);
    if (newName) {
      replacements.push([node.start, node.end, newName]);
    }
  };
  simple(root, {
    Identifier: (node) => replaceIdentifier(node, false),
    AssignmentExpression(node) {
      simple(node.left, {
        Identifier: (node2) => replaceIdentifier(node2, true)
      });
    },
    MemberExpression(node) {
      if (executable === false || node.optional) {
        return;
      }
      if (node.computed === false) {
        const dotIndex = expression.indexOf(".", node.object.end);
        replacements.push([dotIndex, dotIndex, "?"]);
      }
      if (node.computed === true) {
        const dotIndex = expression.indexOf("[", node.object.end);
        replacements.push([dotIndex, dotIndex, "?."]);
      }
    }
  });
  replacements.sort(([leftStart], [rightStart]) => rightStart - leftStart);
  for (const [start, end, fragment] of replacements) {
    const before = expression.slice(0, start);
    const after = expression.slice(end);
    expression = before + fragment + after;
  }
  return expression;
};
var parseObjectExpression = (expression) => {
  const map = /* @__PURE__ */ new Map();
  let root;
  try {
    root = parseExpressionAt(expression, 0, { ecmaVersion: "latest" });
  } catch (error) {
    return map;
  }
  if (root.type !== "ObjectExpression") {
    return map;
  }
  for (const property of root.properties) {
    if (property.type === "SpreadElement") {
      continue;
    }
    if (property.computed) {
      continue;
    }
    let key;
    if (property.key.type === "Identifier") {
      key = property.key.name;
    } else if (property.key.type === "Literal" && typeof property.key.value === "string") {
      key = property.key.value;
    } else {
      continue;
    }
    const valueExpression = expression.slice(
      property.value.start,
      property.value.end
    );
    map.set(key, valueExpression);
  }
  return map;
};
var generateObjectExpression = (map) => {
  let generated = "{\n";
  for (const [key, valueExpression] of map) {
    const keyExpression = JSON.stringify(key);
    generated += `  ${keyExpression}: ${valueExpression},
`;
  }
  generated += `}`;
  return generated;
};
var dataSourceVariablePrefix = "$ws$dataSource$";
var encodeDataSourceVariable = (id) => {
  const encoded = id.replaceAll("-", "__DASH__");
  return `${dataSourceVariablePrefix}${encoded}`;
};
var decodeDataSourceVariable = (name) => {
  if (name.startsWith(dataSourceVariablePrefix)) {
    const encoded = name.slice(dataSourceVariablePrefix.length);
    return encoded.replaceAll("__DASH__", "-");
  }
  return;
};
var generateExpression = ({
  expression,
  dataSources,
  usedDataSources,
  scope
}) => {
  return transpileExpression({
    expression,
    executable: true,
    replaceVariable: (identifier) => {
      const depId = decodeDataSourceVariable(identifier);
      const dep = depId ? dataSources.get(depId) : void 0;
      if (dep) {
        usedDataSources?.set(dep.id, dep);
        return scope.getName(dep.id, dep.name);
      }
    }
  });
};
var executeExpression = (expression) => {
  try {
    const fn = new Function(`return (${expression})`);
    return fn();
  } catch {
  }
};

// src/url-pattern.ts
var tokenRegex = /:(?<name>\w+)(?<modifier>[?*]?)|(?<wildcard>(?<!:\w+)\*)/;
var isPathnamePattern = (pathname) => tokenRegex.test(pathname);
var tokenRegexGlobal = new RegExp(tokenRegex.source, "g");
var matchPathnameParams = (pathname) => {
  return pathname.matchAll(tokenRegexGlobal);
};

// src/page-utils.ts
var ROOT_FOLDER_ID = "root";
var isRootFolder = ({ id }) => id === ROOT_FOLDER_ID;
var findPageByIdOrPath = (idOrPath, pages) => {
  if (idOrPath === "" || idOrPath === "/" || idOrPath === pages.homePage.id) {
    return pages.homePage;
  }
  return pages.pages.find(
    (page) => page.id === idOrPath || getPagePath(page.id, pages) === idOrPath
  );
};
var findParentFolderByChildId = (id, folders) => {
  for (const folder of folders) {
    if (folder.children.includes(id)) {
      return folder;
    }
  }
};
var getPagePath = (id, pages) => {
  const foldersMap = /* @__PURE__ */ new Map();
  const childParentMap = /* @__PURE__ */ new Map();
  for (const folder of pages.folders) {
    foldersMap.set(folder.id, folder);
    for (const childId of folder.children) {
      childParentMap.set(childId, folder.id);
    }
  }
  const paths = [];
  let currentId = id;
  const allPages = [pages.homePage, ...pages.pages];
  for (const page of allPages) {
    if (page.id === id) {
      paths.push(page.path);
      currentId = childParentMap.get(page.id);
      break;
    }
  }
  while (currentId) {
    const folder = foldersMap.get(currentId);
    if (folder === void 0) {
      break;
    }
    paths.push(folder.slug);
    currentId = childParentMap.get(currentId);
  }
  return paths.reverse().join("/").replace(/\/+/g, "/");
};
var getStaticSiteMapXml = (pages, updatedAt) => {
  const allPages = [pages.homePage, ...pages.pages];
  return allPages.filter((page) => (page.meta.documentType ?? "html") === "html").filter(
    (page) => executeExpression(page.meta.excludePageFromSearch) !== true
  ).filter((page) => false === isPathnamePattern(page.path)).map((page) => ({
    path: getPagePath(page.id, pages),
    lastModified: updatedAt.split("T")[0]
  }));
};

// src/scope.ts
import reservedIdentifiers from "reserved-identifiers";
var identifiers = reservedIdentifiers({ includeGlobalProperties: true });
var isReserved = (identifier) => identifiers.has(identifier);
var normalizeJsName = (name) => {
  name = name.replaceAll(/[^\w$]/g, "");
  if (name.length === 0) {
    return "_";
  }
  if (/[A-Za-z_$]/.test(name[0]) === false) {
    name = `_${name}`;
  }
  if (isReserved(name)) {
    return `${name}_`;
  }
  return name;
};
var createScope = (occupiedIdentifiers = [], normalizeName = normalizeJsName, separator = "_") => {
  const nameById = /* @__PURE__ */ new Map();
  const usedNames = /* @__PURE__ */ new Set();
  for (const identifier of occupiedIdentifiers) {
    usedNames.add(identifier);
  }
  const getName = (id, preferredName) => {
    const cachedName = nameById.get(id);
    if (cachedName !== void 0) {
      return cachedName;
    }
    preferredName = normalizeName(preferredName);
    let index = 0;
    let scopedName = preferredName;
    while (usedNames.has(scopedName)) {
      index += 1;
      scopedName = `${preferredName}${separator}${index}`;
    }
    nameById.set(id, scopedName);
    usedNames.add(scopedName);
    return scopedName;
  };
  return {
    getName
  };
};

// src/resources-generator.ts
var generateResources = ({
  scope,
  page,
  dataSources,
  props,
  resources
}) => {
  const usedDataSources = /* @__PURE__ */ new Map();
  let generatedRequests = "";
  for (const resource of resources.values()) {
    let generatedRequest = "";
    const resourceName = scope.getName(resource.id, resource.name);
    generatedRequest += `  const ${resourceName}: ResourceRequest = {
`;
    generatedRequest += `    id: "${resource.id}",
`;
    generatedRequest += `    name: ${JSON.stringify(resource.name)},
`;
    const url = generateExpression({
      expression: resource.url,
      dataSources,
      usedDataSources,
      scope
    });
    generatedRequest += `    url: ${url},
`;
    generatedRequest += `    method: "${resource.method}",
`;
    generatedRequest += `    headers: [
`;
    for (const header of resource.headers) {
      const value = generateExpression({
        expression: header.value,
        dataSources,
        usedDataSources,
        scope
      });
      generatedRequest += `      { name: "${header.name}", value: ${value} },
`;
    }
    generatedRequest += `    ],
`;
    if (resource.body !== void 0 && resource.body.length > 0) {
      const body = generateExpression({
        expression: resource.body,
        dataSources,
        usedDataSources,
        scope
      });
      generatedRequest += `    body: ${body},
`;
    }
    generatedRequest += `  }
`;
    generatedRequests += generatedRequest;
  }
  let generatedVariables = "";
  for (const dataSource of usedDataSources.values()) {
    if (dataSource.type === "variable") {
      const name = scope.getName(dataSource.id, dataSource.name);
      const value = JSON.stringify(dataSource.value.value);
      generatedVariables += `  let ${name} = ${value}
`;
    }
    if (dataSource.type === "parameter") {
      if (dataSource.id !== page.systemDataSourceId) {
        continue;
      }
      const name = scope.getName(dataSource.id, dataSource.name);
      generatedVariables += `  const ${name} = _props.system
`;
    }
  }
  let generated = "";
  generated += `import type { System, ResourceRequest } from "@webstudio-is/sdk";
`;
  generated += `export const getResources = (_props: { system: System }) => {
`;
  generated += generatedVariables;
  generated += generatedRequests;
  generated += `  const _data = new Map<string, ResourceRequest>([
`;
  for (const dataSource of dataSources.values()) {
    if (dataSource.type === "resource") {
      const name = scope.getName(dataSource.resourceId, dataSource.name);
      generated += `    ["${name}", ${name}],
`;
    }
  }
  generated += `  ])
`;
  generated += `  const _action = new Map<string, ResourceRequest>([
`;
  for (const prop of props.values()) {
    if (prop.type === "resource") {
      const name = scope.getName(prop.value, prop.name);
      generated += `    ["${name}", ${name}],
`;
    }
  }
  generated += `  ])
`;
  generated += `  return { data: _data, action: _action }
`;
  generated += `}
`;
  return generated;
};
var getMethod = (value) => {
  switch (value?.toLowerCase()) {
    case "get":
      return "get";
    case "delete":
      return "delete";
    case "put":
      return "put";
    default:
      return "post";
  }
};
var replaceFormActionsWithResources = ({
  props,
  instances,
  resources
}) => {
  const formProps = /* @__PURE__ */ new Map();
  for (const prop of props.values()) {
    if (prop.name === "method" && prop.type === "string" && instances.get(prop.instanceId)?.component === "Form") {
      let data = formProps.get(prop.instanceId);
      if (data === void 0) {
        data = {};
        formProps.set(prop.instanceId, data);
      }
      data.method = prop.value;
      props.delete(prop.id);
    }
    if (prop.name === "action" && prop.type === "string" && prop.value && instances.get(prop.instanceId)?.component === "Form") {
      let data = formProps.get(prop.instanceId);
      if (data === void 0) {
        data = {};
        formProps.set(prop.instanceId, data);
      }
      data.action = prop.value;
      props.set(prop.id, {
        id: prop.id,
        instanceId: prop.instanceId,
        name: prop.name,
        type: "resource",
        value: prop.instanceId
      });
    }
  }
  for (const [instanceId, { action, method }] of formProps) {
    if (action) {
      resources.set(instanceId, {
        id: instanceId,
        name: "action",
        method: getMethod(method),
        url: JSON.stringify(action),
        headers: []
      });
    }
  }
};

// src/page-meta-generator.ts
var generatePageMeta = ({
  globalScope,
  page,
  dataSources,
  assets
}) => {
  const localScope = createScope(["system", "resources"]);
  const usedDataSources = /* @__PURE__ */ new Map();
  const titleExpression = generateExpression({
    expression: page.title,
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const descriptionExpression = generateExpression({
    expression: page.meta.description ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const excludePageFromSearchExpression = generateExpression({
    expression: page.meta.excludePageFromSearch ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const languageExpression = generateExpression({
    expression: page.meta.language ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const socialImageAssetNameExpression = JSON.stringify(
    page.meta.socialImageAssetId ? assets.get(page.meta.socialImageAssetId)?.name : void 0
  );
  const socialImageUrlExpression = generateExpression({
    expression: page.meta.socialImageUrl ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const statusExpression = generateExpression({
    expression: page.meta.status ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  const redirectExpression = generateExpression({
    expression: page.meta.redirect ?? "undefined",
    dataSources,
    usedDataSources,
    scope: localScope
  });
  let customExpression = "";
  customExpression += `[
`;
  for (const customMeta of page.meta.custom ?? []) {
    if (customMeta.property.trim().length === 0) {
      continue;
    }
    const propertyExpression = JSON.stringify(customMeta.property);
    const contentExpression = generateExpression({
      expression: customMeta.content,
      dataSources,
      usedDataSources,
      scope: localScope
    });
    customExpression += `      {
`;
    customExpression += `        property: ${propertyExpression},
`;
    customExpression += `        content: ${contentExpression},
`;
    customExpression += `      },
`;
  }
  customExpression += `    ]`;
  let generated = "";
  generated += `export const getPageMeta = ({
`;
  generated += `  system,
`;
  generated += `  resources,
`;
  generated += `}: {
`;
  generated += `  system: System;
`;
  generated += `  resources: Record<string, any>;
`;
  generated += `}): PageMeta => {
`;
  for (const dataSource of usedDataSources.values()) {
    if (dataSource.type === "variable") {
      const valueName = localScope.getName(dataSource.id, dataSource.name);
      const initialValueString = JSON.stringify(dataSource.value.value);
      generated += `  let ${valueName} = ${initialValueString}
`;
      continue;
    }
    if (dataSource.type === "parameter") {
      if (dataSource.id === page.systemDataSourceId) {
        const valueName = localScope.getName(dataSource.id, dataSource.name);
        generated += `  let ${valueName} = system
`;
      }
      continue;
    }
    if (dataSource.type === "resource") {
      const valueName = localScope.getName(dataSource.id, dataSource.name);
      const resourceName = globalScope.getName(
        dataSource.resourceId,
        dataSource.name
      );
      generated += `  let ${valueName} = resources.${resourceName}
`;
      continue;
    }
  }
  generated += `  return {
`;
  generated += `    title: ${titleExpression},
`;
  generated += `    description: ${descriptionExpression},
`;
  generated += `    excludePageFromSearch: ${excludePageFromSearchExpression},
`;
  generated += `    language: ${languageExpression},
`;
  generated += `    socialImageAssetName: ${socialImageAssetNameExpression},
`;
  generated += `    socialImageUrl: ${socialImageUrlExpression},
`;
  generated += `    status: ${statusExpression},
`;
  generated += `    redirect: ${redirectExpression},
`;
  generated += `    custom: ${customExpression},
`;
  generated += `  };
`;
  generated += `};
`;
  return generated;
};
export {
  Asset,
  Assets,
  Breakpoint,
  Breakpoints,
  CompilerSettings,
  DataSource,
  DataSourceVariableValue,
  DataSources,
  Deployment,
  ExpressionChild,
  Folder,
  FolderName,
  FontAsset,
  HomePagePath,
  IdChild,
  ImageAsset,
  ImageMeta,
  Instance,
  InstanceChild,
  Instances,
  Matcher,
  MatcherOperation,
  MatcherRelation,
  Matchers,
  PageName,
  PagePath,
  PageRedirect,
  PageTitle,
  Pages,
  ProjectNewRedirectPath,
  Prop,
  Props,
  ROOT_FOLDER_ID,
  ROOT_INSTANCE_ID,
  Resource,
  ResourceRequest,
  Resources,
  StyleDecl,
  StyleSource,
  StyleSourceSelection,
  StyleSourceSelections,
  StyleSources,
  Styles,
  Templates,
  TextChild,
  WebstudioFragment,
  createScope,
  decodeDataSourceVariable,
  documentTypes,
  encodeDataSourceVariable,
  executeExpression,
  findPageByIdOrPath,
  findParentFolderByChildId,
  findTreeInstanceIds,
  findTreeInstanceIdsExcludingSlotDescendants,
  generateExpression,
  generateObjectExpression,
  generatePageMeta,
  generateResources,
  getExpressionIdentifiers,
  getPagePath,
  getStaticSiteMapXml,
  getStyleDeclKey,
  initialBreakpoints,
  isLiteralExpression,
  isPathnamePattern,
  isRootFolder,
  lintExpression,
  matchPathnameParams,
  parseComponentName,
  parseObjectExpression,
  replaceFormActionsWithResources,
  transpileExpression
};
