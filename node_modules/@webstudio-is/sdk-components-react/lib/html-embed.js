import { jsx as i } from "react/jsx-runtime";
import { forwardRef as R, useContext as S, useState as b, useSyncExternalStore as x, useRef as f, useMemo as E, useEffect as k } from "react";
import { mergeRefs as T } from "@react-aria/utils";
import { ReactSdkContext as g } from "@webstudio-is/react-sdk/runtime";
import { patchDomEvents as L, executeDomEvents as _ } from "./html-embed-patchers.js";
const C = {
  scriptTestIdPrefix: "client-"
}, w = (e) => new Promise((t, n) => {
  const r = document.createElement("script"), s = e.hasAttribute("src"), a = e.type === "module";
  for (const { name: c, value: o } of e.attributes)
    r.setAttribute(c, o);
  if (r.dataset.testid !== void 0 && (r.dataset.testid = `${C.scriptTestIdPrefix}${r.dataset.testid}`), s)
    r.addEventListener("load", () => {
      t();
    }), r.addEventListener("error", n);
  else {
    if (a) {
      const c = new Blob([e.innerText], {
        type: "text/javascript"
      }), o = URL.createObjectURL(c);
      import(
        /* @vite-ignore */
        o
      ).then(t).catch(n).finally(() => {
        URL.revokeObjectURL(o);
      });
      return;
    }
    r.textContent = e.innerText;
  }
  e.replaceWith(r), s === !1 && t();
}), l = [];
let d = !1;
const O = async (e) => {
  if (l.push(...e), await Promise.resolve(), !d) {
    for (L(), d = !0; l.length > 0; )
      await l.shift()();
    _(), d = !1;
  }
}, H = (e) => {
  const t = e.querySelectorAll("script"), n = [], r = [];
  t.forEach((s) => {
    (s.hasAttribute("async") ? r : n).push(() => w(s));
  });
  for (const s of r)
    s();
  O(n);
}, I = (e) => {
  const { code: t, innerRef: n, ...r } = e;
  return /* @__PURE__ */ i("div", { ref: n, ...r, style: { display: "block", padding: 20 }, children: 'Open the "Settings" panel to insert HTML code.' });
}, h = () => x(
  () => () => {
  },
  () => !1,
  () => !0
), u = (e) => {
  if (!h())
    return e.children;
}, m = (e) => {
  const { code: t, innerRef: n, ...r } = e, s = f(null), a = f(!0), c = E(
    () => ({
      __html: t ?? ""
    }),
    [t]
  );
  return k(() => {
    const o = s.current;
    o && a.current && (a.current = !1, H(o));
  }, []), /* @__PURE__ */ i(
    "div",
    {
      ...r,
      ref: T(n, s),
      dangerouslySetInnerHTML: c
    }
  );
}, p = (e) => {
  const { code: t, innerRef: n, ...r } = e;
  return /* @__PURE__ */ i(
    "div",
    {
      ...r,
      ref: n,
      dangerouslySetInnerHTML: { __html: t ?? "" }
    }
  );
}, M = p, P = R(
  (e, t) => {
    const { code: n, executeScriptOnCanvas: r, clientOnly: s, children: a, ...c } = e, { renderer: o } = S(g), v = h(), [y] = b(v);
    return n === void 0 || String(n).trim().length === 0 ? /* @__PURE__ */ i(I, { innerRef: t, ...c }) : y ? s !== !0 ? /* @__PURE__ */ i(p, { innerRef: t, code: n, ...c }) : /* @__PURE__ */ i(u, { children: /* @__PURE__ */ i(m, { innerRef: t, code: n, ...c }) }) : o === "canvas" && r !== !0 ? /* @__PURE__ */ i(u, { children: /* @__PURE__ */ i(
      M,
      {
        innerRef: t,
        code: n,
        ...c
      }
    ) }) : /* @__PURE__ */ i(u, { children: /* @__PURE__ */ i(
      m,
      {
        innerRef: t,
        code: n,
        ...c
      },
      n
    ) });
  }
);
P.displayName = "HtmlEmbed";
export {
  P as HtmlEmbed,
  C as __testing__
};
