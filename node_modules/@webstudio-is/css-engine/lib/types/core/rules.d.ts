import type { StyleValue } from "../schema";
import { type TransformValue } from "./to-value";
export type StyleMap = Map<string, StyleValue>;
export declare const generateStyleMap: ({ style, indent, transformValue, }: {
    style: StyleMap;
    indent?: number;
    transformValue?: TransformValue;
}) => string;
export type Declaration = {
    breakpoint: string;
    selector: string;
    property: string;
    value: StyleValue;
};
type DeclarationKey = Omit<Declaration, "value">;
/**
 * Reusable style rule in any nesting rule
 *
 * @mixin name {
 *   \@media breakpoint {
 *     &selector {
 *       property: value
 *     }
 *   }
 * }
 */
export declare class MixinRule {
    #private;
    isDirtyBreakpoint(breakpoint: string): boolean;
    /**
     * reset breakpoints invalidation
     */
    clearBreakpoints(): void;
    setDeclaration(declaration: Declaration): void;
    deleteDeclaration(declaration: DeclarationKey): void;
    getDeclarations(): MapIterator<Declaration>;
}
/**
 * Universal style rule with nested selectors and media queries support
 * Rules are generated by each media query
 * and heavily cached to avoid complex computation
 *
 * selector {
 *   \@media breakpoint {
 *     &selector {
 *       property: value
 *     }
 *   }
 * }
 */
export declare class NestingRule {
    #private;
    constructor(mixinRules: Map<string, MixinRule>, selector: string, descendantSuffix: string);
    getSelector(): string;
    setSelector(selector: string): void;
    getDescendantSuffix(): string;
    addMixin(mixin: string): void;
    applyMixins(mixins: string[]): void;
    setDeclaration(declaration: Declaration): void;
    deleteDeclaration(declaration: DeclarationKey): void;
    getMergedDeclarations(): Declaration[];
    toString({ breakpoint, indent, transformValue, }: {
        breakpoint: string;
        indent?: number;
        transformValue?: TransformValue;
    }): string;
}
export type MediaRuleOptions = {
    minWidth?: number;
    maxWidth?: number;
    mediaType?: "all" | "screen" | "print";
};
export declare class MediaRule {
    #private;
    options: MediaRuleOptions;
    rules: Map<string, PlaintextRule>;
    constructor(name: string, options?: MediaRuleOptions);
    insertRule(rule: PlaintextRule): PlaintextRule;
    get cssText(): string;
    toString(): string;
    generateRule({ nestingRules, transformValue, }: {
        nestingRules: NestingRule[];
        transformValue?: TransformValue;
    }): string;
}
export declare class PlaintextRule {
    cssText: string;
    constructor(cssText: string);
    toString(): string;
}
export type FontFaceOptions = {
    fontFamily: string;
    fontStyle?: "normal" | "italic" | "oblique";
    fontWeight?: number | string;
    fontDisplay: "swap" | "auto" | "block" | "fallback" | "optional";
    src: string;
};
export declare class FontFaceRule {
    #private;
    constructor(options: FontFaceOptions);
    get cssText(): string;
    toString(): string;
}
export {};
